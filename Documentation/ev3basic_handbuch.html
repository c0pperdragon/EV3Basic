<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
<HEAD>
<meta charset="utf-8"/>
<TITLE>EV3Basic Benutzerhandbuch</TITLE>
<style type="text/css">
  H1.chapter {
	margin-top: 100px;
    font-family: Verdana; 
  }
  H3.subchapter {
    font-family: Verdana; 
  }
  P {
    font-family: Verdana; 
  }
  UL {
    font-family: Verdana; 
  }
  ADDRESS {
    font-family: Verdana; 
	float: right;
  }
  TABLE {
    font-family: Verdana;
	border-spacing: 0px;
	border:1px solid black;
  }
  TD {
	padding: 4px;
  }
  TR:nth-child(1)
  {
	background: #d0d0d0;
  } 
  TD:nth-child(1)
  {
	background: #d0d0d0;
  } 

  H2.object {
    font-family: Verdana; 
	border-bottom: medium solid;
  }
  P.objectsummary {
    font-family: Verdana; 
  }
  H3.operation {
    font-family: Verdana;  
	margin-top: 20px;
	margin-bottom: 10px;
	margin-left: 20px; 
  }
  P.operationsummary {
    font-family: Verdana; 
	margin-top: 10px;
	margin-bottom: 10px;
	margin-left: 20px; 
  }
  H3.property {
    font-family: Verdana;  
	margin-top: 20px;
	margin-bottom: 10px;
	margin-left: 20px; 
  }
  P.propertysummary {
    font-family: Verdana; 
	margin-top: 10px;
	margin-bottom: 10px;
	margin-left: 20px; 
  }
  H4.parameter {
    font-family: Verdana; 
	margin-top: 0px;
	margin-bottom: 0px;
	margin-left: 50px; 
  }
  P.parametersummary {
    font-family: Verdana;
	margin-top: 0px;
	margin-bottom: 10px;
	margin-left: 50px; 
  }
  H4.returns {
    font-family: Verdana; 
	margin-top: 0px;
	margin-bottom: 0px;
	margin-left: 50px; 
  }
  P.returnssummary {
    font-family: Verdana;
	margin-top: 0px;
	margin-bottom: 10px;
	margin-left: 50px; 
  }
</style>

</HEAD>
<BODY>
<H1 class="chapter">EV3Basic</H1>
<P>
Einen Roboter nach eigenen Ideen zu programmieren macht Spaß. Am einfachsten gelingt das Programmieren einfacher Aufgaben 
mit der grafischen Software von Lego.
Für größere und komplexere Programme braucht man jedoch eine textbasierte Programmiersprache.
Es gibt auch viele verschiedene Projekte, um Programmiersprachen für den EV3 zu adaptieren (LeJOS, MonoBrick, RobotC, ev3dev, and andere).
Aber alle haben eine Sache gemeinsam: Sie sind unglaublich schwierig zum Laufen zu bringen und zu benutzen. Man benötigt 
jahrelange Erfahrung, um auch nur eine davon benutzen zu können.
</P>
<P>
Um diese Lücke zwischen ganz-einfach-aber-eingeschränkt und allmächtig-aber-schwierig zu füllen, habe ich EV3Basic entwickelt. 
Diese Sprache ist speziell auf EV3-Benutzer zugeschnitten, die über die Beschränkungen der grafischen Programmierung hinausgehen 
wollen, selbst aber noch keine IT-Profis sind.
EV3Basic ist recht einfach zu lernen und bietet trotzdem alle Möglichkeiten, komplexere Steuerungen zu entwickeln. 
Dabei programmieren zu lernen, ist noch ein zustätzlicher Bonus.
</P>
<P>
EV3Basic basiert auf der Programmiersprache "Small Basic" von Microsoft, die für Kinder oder allgemein für Anfänger als Möglichkeit eines 
Einstiegs ins Programmieren geschaffen wurde. "Small Basic" wurde absichtlich einfach gehalten und für meine EV3-Erweiterung have ich versucht,
das selbe Prinzip anzuwenden.
Ich würde mich sehr freuen, wenn diese Sprache tatsächlich dabei helfen könnte, programmieren zu lernen und den EV3 kreativer zu benutzen.
</P>
<address>
Reinhard Grafl
<br>
reinhard.grafl@aon.at
</address>

<H1 class="chapter">Erste Schritte</H1>
<P>
Was man zuerst braucht, ist ein PC mit Microsoft Windows (jede Version seit Windows XP) und die aktuelle Version von
<a href="http://smallbasic.com">Microsoft Small Basic</a> die man sich gratis runterladen kann. Für komplette Programmier-Neulinge empfehle 
ich die Tutorials auf Small Basic - Webseite um die grundlegenden Prinzipien zu erlernen. Das dauert nicht all zu lange und macht für sich
alleine auch schon Spaß. 
</P>
<P>
Der nächste Schritt ist, die EV3-Erweiterung für Small Basic runterzuladen und zu installieren.
Bei der <a href="https://github.com/c0pperdragon/EV3Basic/releases">neuesten Version</a> gibt es die Datei "EV3BasicInstaller.msi", die 
man gratis runterladen und installieren kann. 
Die Installation muss direkt in das selbe Verzeichnis wie Small Basic gespeichert werden. Normalerweise ist das schon richtig voreingestellt, wenn man
den Installationspfad vom vorigen Schritt auch nicht verändert hat.
Beim nächsten Start von Small Basic, hat man Zugriff auf verschiedene Objekte, mit denen sich die unterschiedlichen Aspekte des EV3-Bricks ansteuern lassen, 
sowie noch ein paar weitere universell nützliche Objekte. 
</P>
<P>
Als erstes Programm könnte man 
</P>
<pre>
   LCD.Clear()
   LCD.Write(40,40, "Hello EV3")
   Program.Delay(10000)
</pre>
<P>
in das Programm-Fenster tippen (oder kopieren).
Sobald der EV3-Brick über ein USB-Kabel mit dem PC verbunden und eingeschaltet ist, kann man das Programm
mit dem großen blauen "Ausführen" - Knopf von Small Basic starten.
</P>
<P>
Während des Programmierens zeigt das Intellisense-System von Small Basic die möglichen Bibliotheksfunktionen und Erklärungen
für deren Benutzung. Diese Information is die selbe wie im Kapitel "Programmierbibliotheken".
Es sind noch viele zusätzliche Beispiel auf der EV3Basic Webseite als 'Examples.zip' verfügbar. 
</P>
<P>
Den EV3-Brick vom PC aus fernzusteuern ist eine gute Sache, aber für viele Anwendungen ist es besser, das Programm direkt 
auf dem Roboter auszuführen, unabhängig von einem PC, der jeden einzelnen Schritt festlegen muss.
</P>
<P>
Um das Programm auf den Brick zu bekommen, gibt es den EV3Explorer, der gleichzeit mit der EV3-Erweiterung mitinstalliert wurde, und
nun über das Windows Start Menü (EV3Basic/EV3Explorer) geöffnet werden kann. Dieses Programm zeigt ein Fenster mit zwei Hälften: Links 
sieht man die Dateien, die am Brick gespeichert sind und rechts die Dateien am PC. 
Man kann jedes der Beispiele oder jedes eigene Programm übersetzen und am Brick starten, indem man es auswählt und "Compile and Run" drückt.
Dadurch wird das Quellprogramm in eine für den Brick verständliche Form übersetzt (in eine Datei mit der Erweiterung .rbf), auf den 
Brick übertragen und sofort gestartet.
Wenn das Programm auch im Menu auf dem Brick sichtbar sein soll, muss zuerst ein Unterverzeichnis des "prjs"-Verzeichnisses mit einem 
aussagekräftigen Namen erstellt werden, in das das ausführbare Programm hineinkopiert werden muss (Der EV3-Brick zeigt nur Programme im Menü
an, die auch in ihrem eigenen Unterverzeichnis liegen).
</P>

<H1 class="chapter">Kurzreferenz für Small Basic</H1>
<p>
Für Personen, die bereits in der einen oder anderen Sprache programmieren können, und die nicht die Small Basic Tutorials für die grundlegendsten
Dinge durcharbeiten wollen, habe ich hier ein kleines Beispiel zusammengestellt, in dem die meisten Sprachkonstrukte von
Small Basic vorkommen. 
Das Beispiel läuft nicht am EV3-Brick sondern nur am PC, weil es das TextWindow - Objekt benutzt.
</p>
<pre>

  ' Demo-Programm zur Erklärung der meisten Small Basic - Elemente
  ' (alle Kommentare starten mit einfachem Hochkomma)

  ' Ausführung startet hier
  A = 5       ' Variablen werden implizit bei der ersten Benutzung deklariert
  a = a + 1   ' Groß- und Kleinschreibung wird nie unterschieden
  B[a] = 55   ' Arrays werden implizit deklariert und wachsen bei Bedarf
  X = "hi"    ' Variablen können auch Text enthalten

  Sub write   ' Definiert ein Unterprogramm (Parameter sind nicht möglich)
	TextWindow.WriteLine(X)           ' Aufruf einer Bibliotheksfunktion, Zugriff auf Variable
  EndSub
     ' Ablauf des Hauptprogramms fließt um die Sub-Definition herum

  TextWindow.WriteLine("A="+a)        ' Texte werden mit + zusammengesetzt
  WRITE()                             ' Aufruf eines Unterprogrammes. Groß- und Kleinschreibung ist egal.
  write2()                            ' Kann Unterprogramm aufrufen, das erst später im Code definiert wird.

  TextWindow.Writeline("B[6]="+B[6])  ' Zugriff auf Arrays
  
  For i=2 to 5 		               	  ' Eine Schleife von 2 bis 5 (inclusive)
	TextWindow.Writeline("I:"+I)
  EndFor
  For i=6.5 to 10.5 step 2         	  ' Eine Schleife mit nicht-ganzzahligen Werten und größeren Schritten
	TextWindow.Writeline("I:"+I)
  EndFor

  Sub write2
	write()          ' Unterprogramm ruft andereres Unterprogramm auf
	write()
  EndSub
     ' Ablauf des Hauptprogramms fließt um die Sub-Definition herum

   I=99				' i und I sind zwei Schreibungen für die gleiche Variable
   while i>3        ' Schleife mit Bedingung
     i=i/2
     TextWindow.Writeline("I:"+i)
   endwhile
   TextWindow.WriteLine("PI="+Math.PI)         ' Eine Bibliotheks-Eigenschaft (Zugriff ohne Klammern)
   TextWindow.WriteLine("SIN="+Math.Sin(0.5))  ' Eine Bibliotheks-Funktioen mit Rückgabewert

   A=50
   B=20
   If a<5 then				       ' Eine bedingte Anweisung mit mehreren Möglichkeiten
		TextWindow.WriteLine("first")
   elseif a<10 and b<100 then                ' logische 'and' - Verknüpfung
		TextWindow.WriteLine("second")
   elseif a<20 or (b>40 and b<60) then       ' verschachtelte logische Verknüpfungen
		TextWindow.WriteLine("third")
   else
		TextWindow.WriteLine("other")
   endif
</pre>


<H1 class="chapter">Unterschiede zwischen Small Basic and EV3Basic</H1>
<P>
Obwohl ich versucht habe, das Originalverhalten von Small Basic in meinem EV3-Compiler so gut wie
möglich zu imitieren, gibt es doch einige Dinge, die mit der Laufzeitumgebung des EV3-Bricks nicht möglich sind.
</P>

<H3 class="subchapter">Variablen haben einen Datentyp</H3>
<P>  
Während Small Basic in jede Variable abwechselnd sowohl Zahlen oder Texte oder ganze Arrays speichern kann, 
erhält bei EV3-Basic jede Variable einen der folgenden Datentypen:

</P>
<ul>
<li>Zahl  (eine 32bit Fließkommazahl)</li>
<li>Text    </li>
<li>Array von Zahlen</li>
<li>Array von Texten</li>
</ul>
<P>
Jede Variable bekommt bei der ersten Benutzung im Programm einen dieser Typen zugewiesen und kann
ab dann nichts anderes als Werte dieses Types speichern. 
</P>

<H3 class="subchapter">Operatoren und Funktionen arbeiten entsprechend der Operanden-Typen</H3>
<P>
Arithmetische oder logische Operatoren müssen mit spezifischen Datentypen benutzt werden und liefern ebenfalls 
einen definierten Datentyp als Ergebnis (z.B. der Operator "<" erhält zwei Zahlen und liefert einen Text).
Eine Ausnahme sind die Gleichheits/Ungleichheits-Operatoren, die entweder mit Zahlen oder Texten arbeiten, abhängig
von den Datentypen der Operanden. Zweite Ausnahme ist der "+" - Operator, der entweder Zahlen addiert, oder
Texte zusammenhängt.
Ähnliche Einschränkungen gibt es für die Parameter von Bibliotheksfunktionen, die jeweils einen fixen Typ erwarten. 
Als kleine Erleichterung werden dort Zahlen automatisch in Texte konvertiert, wenn die Funktion einen Text benötigt 
(aber nicht anders herum).
</P>

<H3 class="subchapter">Arrays</H3>
<P>
Die Arrays von Small Basic arbeiten sehr universell und können jede Zahl oder jeden Text als Index verwenden. 
EV3-Basic kann das nicht. Nur Zahlen sind als Index erlaubt, und nur nicht-negative ganze Zahlen funktionieren wie erwartet.
 (A[4.5] ist das selbe wie A[4], A[-4] liefert aber immer 0 oder "")
Es gibt keine Unterstütztung für mehrdimensionale Arrays.
Arrays können an Bibliotheksfunktionen übergeben werden. Array-Rückgabewerte müssen aber jeweils sofort in eine Variable gespeichert werden
und können nicht statt dessen sofort an andere Funktionen geschickt werden (es gibt keinen automatisch angelegten temporären Speicher für Arrays).
<P>

<H3 class="subchapter">Einschränkungen bei Text</H3>
<P>
Jede Variable vom Typ Text kann maximal 251 Zeichen enthalten und die möglichen Zeichen beschränken sich 
auf die Unicode-Werte 1 - 255.
Das selbe gilt für alle Elemente eines Text-Arrays.
</P>

<H1 class="chapter">Bluetooth-Unterstützung</H1>
<P>
Die einfachste und verlässlichste Methode, den EV3 mit dem PC zu verbinden, ist über ein USB-Kabel.
Aber in manchen Fällen ist eine Kabelverbindung zu unpraktisch, vor allem bei mobilen Robotern.
</P>
<P>
Wenn der PC Bluetooth unterstützt (entweder mit einem Dongle oder schon eingebaut), kann der EV3 
so konfiguriert werden, dass die Kommunikation auch drahtlos möglich ist.
Wenn es noch nicht bereits geschehen ist, muss der EV3 zur Liste der Bluetooth-Geräte am
PC hinzugefügt werden. Zuerst muss Bluetooth am EV3 aktiviert werden. Dazu müssen im Einstellungs-Menü die Punkte
"Bluetooth" und  "Visibility" angewählt werden.
Am PC muss man dann in der Übersicht der Bluetooth-Geräte das neue Gerät suchen und hinzufügen. Nach einigen 
weiteren geführten Schritten, bei denen man auch am EV3 den Zugriff zulassen, und einen Kopplungs-Code 
(ist normalerweise "1234") eingeben muss, sollte die Verbindung hergestellt sein.
</P>
<P>
Sobald es eine Verbindung gibt, und die notwendigen Gerätetreiber automatisch installiert wurden,
kann der PC mit dem EV3 über einen sogenannten "Seriellen Anschluss" kommunizieren. Dieser Anschluss hat
eine Bezeichnung in der Form "COM1", "COM2", oder ähnlich. Der tatsächlich vergebene Name ist
in der Eigenschafts-Seite des Bluetooth-Gerätes ersichtlich.
</P>
<P>
Um diese neue Verbindung mit EV3-Basic zu verwenden, muss man nur das Programm wie gewohnt vom Small Basic
starten, oder den EV3-Explorer benutzen. Falls kein EV3 an einem USB-Anschluss gefunden werden kann, zeigt 
das Programm weitere Möglichkeiten an. In dem Dialogfenster erscheinen auch alle potentiellen "Seriellen
Anschlüsse", an denen ein EV3 verbunden sein könnte. Wenn man den richtigen auswählt, sollte
eine Verbindung funktionieren.
</P>

<H1 class="chapter">WiFi-Unterstützung (WLAN)</H1>
<P>
Wie die Bluetooth-Verbindung, dient eine Kommunikation über WiFi ebenfalls zur drahtlosen
Kommunikation zwischen dem PC und dem EV3-Brick. WiFi hat einige Vorteile, wie höhere Geschwindigkeit,
Reichweite und Stabilität. Es hat aber auch Nachteile wie größeren Stromverbrauch und die Tatsache,
dass man einen WiFi-Dongle an den EV3 anstecken muss. Außerdem funktioniert das nur, wenn man 
auch einen WiFi-Router zur Verfügung hat.
Teilweise ist es eine Geschmackssache, ob man Bluetooth oder das WiFi verwenden will.
</P>
<P>
Um die WiFi-Variante zu benutzen, benötigt man einen speziellen Dongle, der kompatibel mit dem EV3 ist.
Derzeit gibt es nur ein einziges Modell das mit einem unmodifizierten EV3 funktioniert: "Netgear WNA1100", der
an den großen USB-Stecker an der linken Seite des EV3 angesteckt wird.
Die Verbindung kann man direkt am Einstellungs-Menü vom EV3 einrichten. Man muss zuerst die Option "WiFi" aktivieren
(das dauert ein bisschen bis der Dongle gestartet ist) und dann muss man die Verbindung zum WiFi-Router herstellen.
Für den Fall, dass das Wifi-Netzwerk durch Verschlüsselung geschützt ist, muss hier der WPA2-Schlüssel
eingegeben werden. Derzeit werden keine anderen Verschlüsselungsmethoden unterstützt.
</P>
<P>
Sobald eine Verbindung zwischen EV3 und Router hergestelllt ist, sollte der EV3 eine IP-Adresse erhalten haben.
Diese Adresse in der Form "10.2.3.4" oder ähnlich, wird im Einstellungs-Menu im Punkt "Brick Info" ganz unten
in der Liste angezeigt.
</P>
<P>
Um endlich den EV3 von Small Basic oder mit dem EV3-Explorer anzusteuern, muss man den "WiFi"-Button im Dialogfenster,
das nach der richtigen Verbindungsmethode fragt, drücken. 
Dort muss die IP-Adresse genauso wie vom Brick angezeigt eingegeben werden. Das muss man nur einmal machen,
diese Adresse wird am PC für zukünftige Verwendung gespeichert.
</P>
<P>
Achtung: Der EV3-Brick verbindet sich nach dem Start nicht automatisch mit dem Router. Das muss jedesmal von Hand veranlasst werden.
</P>

<H1 class="chapter">Dokumentation der Bibliotheksfunktionen</H1>
<P>
Die Laufzeit-Bibliothek für den EV3 besteht aus einzelnen Komponenten, die 'Objekte' genannt werden. Jedes Objekt 
stellt Funktionen für einen spezifischen Teil des Systemes bereit.
Diese Liste enthält alle Objekte, die sowohl für Small Basic am PC (mit der EV3-Erweiterung) als auch am EV3-Brick selbst verfügbar sind.
Beim Schreiben vom Programmen, die sowieso nur am PC laufen sollen, kann man auch alle weiteren Objekte von Small Basic benutzen.
Sie sind hier aber nicht beschrieben.
</P>

<H2 class="object">Assert</H2>
<P class="objectsummary">Das Assert-Objekt unterstützt den Programmierer dabei, Teile des Programmes auf Korrektheit zu überprüfen.<BR>Eine 'Assertion' macht implizite Annahmen über das Programmverhalten explizit. Durch Hinzufügen von Assertions, kann man Fehler im Programm leicher finden. Wenn zum Beispiel ein Teil des Programmes davon ausgeht, dass die Variable A einen positiven Wert hat, dann kann man das mit Assert.Greater(A,0,"A muss > 0 sein!") an dieser Stelle überprüfen. <BR>Falls das Programm auf eine Assertion trifft, die nicht erfüllt ist, wird eine entsprechende Fehlermeldung im Textfenster oder am Bildschirm des EV3 ausgegebeben.</P>
<H3 class="operation">Assert.Equal (a, b, message)</H3>
<P class="operationsummary">Prüft, ob zwei Werte völlig identisch sind. Bei diesem Test gelten sogar "True" und "tRue" als verschieden.</P>
<H4 class="parameter">a</H4>
<P class="parametersummary">Erster Wert</P>
<H4 class="parameter">b</H4>
<P class="parametersummary">Zweiter Wert</P>
<H4 class="parameter">message</H4>
<P class="parametersummary">Fehlermeldung, die ausgegeben wird, wenn der Test fehlschlägt.</P>
<H3 class="operation">Assert.Failed (message)</H3>
<P class="operationsummary">Gibt eine Fehlermeldung am Bildschirm aus. Dieser Befehl soll nur verwendet werden, wenn bereits ein Fehler erkannt wurde.</P>
<H4 class="parameter">message</H4>
<P class="parametersummary">Fehlermeldung, die ausgegeben werden soll</P>
<H3 class="operation">Assert.Greater (a, b, message)</H3>
<P class="operationsummary">Prüft, ob der erste Wert größer als der zweite Wert ist.</P>
<H4 class="parameter">a</H4>
<P class="parametersummary">Erster Wert</P>
<H4 class="parameter">b</H4>
<P class="parametersummary">Zweiter Wert</P>
<H4 class="parameter">message</H4>
<P class="parametersummary">Fehlermeldung, die ausgegeben wird, wenn der Test fehlschlägt.</P>
<H3 class="operation">Assert.GreaterEqual (a, b, message)</H3>
<P class="operationsummary">Prüft, ob der erste Wert größer als der zweite Wert oder gleich ist.</P>
<H4 class="parameter">a</H4>
<P class="parametersummary">Erster Wert</P>
<H4 class="parameter">b</H4>
<P class="parametersummary">Zweiter Wert</P>
<H4 class="parameter">message</H4>
<P class="parametersummary">Fehlermeldung, die ausgegeben wird, wenn der Test fehlschlägt.</P>
<H3 class="operation">Assert.Less (a, b, message)</H3>
<P class="operationsummary">Prüft, ob der erste Wert kleiner als der zweite Wert ist.</P>
<H4 class="parameter">a</H4>
<P class="parametersummary">Erster Wert</P>
<H4 class="parameter">b</H4>
<P class="parametersummary">Zweiter Wert</P>
<H4 class="parameter">message</H4>
<P class="parametersummary">Fehlermeldung, die ausgegeben wird, wenn der Test fehlschlägt.</P>
<H3 class="operation">Assert.LessEqual (a, b, message)</H3>
<P class="operationsummary">Prüft, ob der erste Wert kleiner als der zweite Wert oder gleich ist.</P>
<H4 class="parameter">a</H4>
<P class="parametersummary">Erster Wert</P>
<H4 class="parameter">b</H4>
<P class="parametersummary">Zweiter Wert</P>
<H4 class="parameter">message</H4>
<P class="parametersummary">Fehlermeldung, die ausgegeben wird, wenn der Test fehlschlägt.</P>
<H3 class="operation">Assert.Near (a, b, message)</H3>
<P class="operationsummary">Prüft, ob zwei Werte gleich beziehungsweise fast gleich sind. 'Fast gleich' bedeutet, dass ein geringer Unterschied, der eventuell durch Rundungsfehler entstanden ist, auch noch zulässig ist.</P>
<H4 class="parameter">a</H4>
<P class="parametersummary">Erster Wert</P>
<H4 class="parameter">b</H4>
<P class="parametersummary">Zweiter Wert</P>
<H4 class="parameter">message</H4>
<P class="parametersummary">Fehlermeldung, die ausgegeben wird, wenn der Test fehlschlägt.</P>
<H3 class="operation">Assert.NotEqual (a, b, message)</H3>
<P class="operationsummary">Prüft, ob zwei Werte verschieden sind. Bei diesem Test gelten sogar "True" und "tRue" als verschieden.</P>
<H4 class="parameter">a</H4>
<P class="parametersummary">Erster Wert</P>
<H4 class="parameter">b</H4>
<P class="parametersummary">Zweiter Wert</P>
<H4 class="parameter">message</H4>
<P class="parametersummary">Fehlermeldung, die ausgegeben wird, wenn der Test fehlschlägt.</P>
<H2 class="object">Buttons</H2>
<P class="objectsummary">Dieses Objekt liest den Zustand der Tasten und die letzten Tastendrücke.<BR>Die Tasten werden mit den folgenden Buchstaben angesprochen:<BR>U   Hinauf<BR>D   Hinunter<BR>L   Links<BR>R   Rechts<BR>E   Mittlere Taste</P>
<H3 class="property">Buttons.Current - Eigenschaft</H3>
<P class="propertysummary">Liest alle Tasten, die gedrückt sind. <BR>Diese Eigenschaft enthält die Buchstaben für alle Tasten, die jetzt gerade in diesem Moment niedergedrückt sind.</P>
<H3 class="operation">Buttons.Flush ()</H3>
<P class="operationsummary">Löscht alle gespeicherten Tastendrücke. Spätere Aufrufe von GetClicks liefern nur mehr die Tasten, die nach dem Flush gedrückt wurden.</P>
<H3 class="operation">Buttons.GetClicks ()</H3>
<P class="operationsummary">Erkennt, welche Tasten in der Zeit seit dem letzten Aufruf von GetClicks am Brick gedrückt wurden.<BR>Der 'gedrückt' - Zustand der Tasten wird dabei gelöscht. Außerdem wird automatisch ein Klick-Geräusch erzeugt, wenn ein Tastendruck erkannt wurde.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Ein Text der die Buchstaben aller gedrückten Tasten enthält (kann auch leer sein)</P>
<H3 class="operation">Buttons.Wait ()</H3>
<P class="operationsummary">Wartet bis zumindest eine Taste am Brick gedrückt wird. Falls eine Taste bereits vorher gedrückt war und der Tastendruck noch nicht mit GetClicks abgeholt wurde, dann kehrt dieser Befehl sofort zurück.</P>
<H2 class="object">EV3</H2>
<P class="objectsummary">Nützliche kleine Funktionen für verschiedene Teile des EV3-Bricks.</P>
<H3 class="property">EV3.BatteryLevel - Eigenschaft</H3>
<P class="propertysummary">Aktueller Ladezustand der Batterie in Prozent (Wertebereich 0 bis 100).</P>
<H3 class="property">EV3.Time - Eigenschaft</H3>
<P class="propertysummary">Die Zeit in Millisekunden seit dem Start des Programmes.</P>
<H3 class="operation">EV3.QueueNextCommand ()</H3>
<P class="operationsummary">Reduziert den Kommunikationsaufwand, wenn das Programm am PC läuft und den EV3 fernsteuert: Das nächste Kommando wird nicht sofort an den EV3 geschickt, sondern erst wenn noch ein weiteres Kommando geschickt werden muss. Man kann das Abschicken mit weiteren QueueNextCommand - Befehlen noch weiter verzögern, um möglichst viele Befehle als ganzen Block auf einmal zu schicken. <BR>Wenn das Programm direkt am EV3 läuft, hat dieser Befehl keine Auswirkung.</P>
<H3 class="operation">EV3.SetLEDColor (color, effect)</H3>
<P class="operationsummary">Setzt die Farbe der Tasten-Beleuchtung und einen der optischen Effekte.</P>
<H4 class="parameter">color</H4>
<P class="parametersummary">Eines der folgenden: "OFF", "GREEN", "RED", "ORANGE"</P>
<H4 class="parameter">effect</H4>
<P class="parametersummary">Eines der folgenden: "NORMAL", "FLASH", "PULSE"</P>
<H3 class="operation">EV3.SystemCall (commandline)</H3>
<P class="operationsummary">Führt einen externen Befehl das Linux-Systems aus. Alle Threads des Basic-Programmes werden so lange angehalten, bis der Systembefehl beendet ist. <BR>Um das vernünftig benutzen zu können, benötigt man entsprechende Linux-Kenntnisse.</P>
<H4 class="parameter">commandline</H4>
<P class="parametersummary">Auszuführendes Systemkommando.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Exit-Status des Kommandos.</P>
<H2 class="object">EV3File</H2>
<P class="objectsummary">EV3File dient zum Ansprechen des Dateisystems auf dem Brick, um Daten zu lesen und zu schreiben.<BR>Dateinamen können entweder absolut (mit führendem '/') oder relativ zum 'prjs'-Verzeichnis sein.</P>
<H3 class="operation">EV3File.Close (handle)</H3>
<P class="operationsummary">Schließt eine offene Datei.</P>
<H4 class="parameter">handle</H4>
<P class="parametersummary">Die Nummer, die vom Open... - Befehl zurückgeben wurde.</P>
<H3 class="operation">EV3File.ConvertToNumber (text)</H3>
<P class="operationsummary">Befehl um einen Text in eine Zahl zu konvertieren.</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Ein Text, der die dezimale Darstellung einer Zahl (mit optionalen Nachkommastellen) enthält.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Die Zahl</P>
<H3 class="operation">EV3File.OpenAppend (filename)</H3>
<P class="operationsummary">Öffnet eine Datei zum Hinzufügen von Dateien. Falls die Datei noch nicht existiert, wird sie angelegt.</P>
<H4 class="parameter">filename</H4>
<P class="parametersummary">Name der Datei, die erweitert bzw. angelegt werden soll.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Eine Nummer mit der die offene Datei später angesprochen wird.</P>
<H3 class="operation">EV3File.OpenRead (filename)</H3>
<P class="operationsummary">Öffnet eine Datei zum Lesen. Falls die Datei nicht existiert, wird 0 zurückgeben.</P>
<H4 class="parameter">filename</H4>
<P class="parametersummary">Name der Datei, von der gelesen werden soll.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Eine Nummer, mit der die offene Datei später angesprochen wird, oder 0 falls die Datei nicht existiert.</P>
<H3 class="operation">EV3File.OpenWrite (filename)</H3>
<P class="operationsummary">Öffnet eine Datei zum Schreiben. Falls die Datei schon existiert, wird sie überschrieben.</P>
<H4 class="parameter">filename</H4>
<P class="parametersummary">Name der Datei die angelegt bzw. überschrieben werden soll.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Eine Nummer, mit der die offene Datei später angesprochen wird.</P>
<H3 class="operation">EV3File.ReadByte (handle)</H3>
<P class="operationsummary">Liest ein einzelnes Byte aus einer Datei.</P>
<H4 class="parameter">handle</H4>
<P class="parametersummary">Die Nummer, die vom Open... - Befehl zurückgegeben wurde.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Das nächste Byte aus der Datei.</P>
<H3 class="operation">EV3File.ReadLine (handle)</H3>
<P class="operationsummary">Liest eine Zeile Text aus einer Datei. Der Text wird bis zum Zeilenumbruch (code 10) aus der Datei gelesen und entsprechend ISO-8859-1 dekodiert.</P>
<H4 class="parameter">handle</H4>
<P class="parametersummary">Die Nummer, die vom Open... - Befehl zurückgegeben wurde.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der Text, der aus der Datei gelesen wurde.</P>
<H3 class="operation">EV3File.ReadNumberArray (handle, size)</H3>
<P class="operationsummary">Liest ein ganzes Array von Zahlen im Binärformat aus einer Datei. Die Zahlen müssen als einfache IEEE-Fließkommazahlen (4 Byte pro Zahl) in der Datei vorliegen.</P>
<H4 class="parameter">handle</H4>
<P class="parametersummary">Die Nummer, die vom Open... - Befehl zurückgeben wurde.</P>
<H4 class="parameter">size</H4>
<P class="parametersummary">Anzahl der Zahlen, die gelesen werden sollen.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Ein Array mit den gelesenen Zahlen.</P>
<H3 class="operation">EV3File.TableLookup (filename, bytes_per_row, row, column)</H3>
<P class="operationsummary">Hilfsfunktion, um aus einer möglicherweise extrem großen Datei ein einzelnes Byte herauszulesen.<BR>Weil die Datei so groß sein kann, dass der Wertebereich normaler, vom EV3 unterstützter Zahlen, nicht mehr ausreicht, um alle Bytes zu adressieren, ist es möglich die Datei mit einer Zeilen/Spalten-Adressierung anzusprechen.</P>
<H4 class="parameter">filename</H4>
<P class="parametersummary">Der Name der Datei.</P>
<H4 class="parameter">bytes_per_row</H4>
<P class="parametersummary">Wenn man eine Zeilen/Spalten-Adressierung verwenden will, ist das die Länge der einzelnen Zeilen. Ansonsten muss man hier 1 verwenden um jedes Byte als eigene Zeile zu interpretieren.</P>
<H4 class="parameter">row</H4>
<P class="parametersummary">Welche Zeile soll genommen werden (start bei 0)?</P>
<H4 class="parameter">column</H4>
<P class="parametersummary">Welche Spalte soll genommen werden (start bei 0)?</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Das Byte an der gewünschten Stelle.</P>
<H3 class="operation">EV3File.WriteByte (handle, data)</H3>
<P class="operationsummary">Schreibt ein einzelnes Byte in die Datei.</P>
<H4 class="parameter">handle</H4>
<P class="parametersummary">Die Nummer, die vom Open... - Befehl zurückgeben wurde.</P>
<H4 class="parameter">data</H4>
<P class="parametersummary">Ein Byte, das geschrieben werden soll (Eine Zahl von 0 bis 255).</P>
<H3 class="operation">EV3File.WriteLine (handle, text)</H3>
<P class="operationsummary">Schreibt eine Zeile Text in die Datei. Der Text wird entsprechend ISO-8859-1 kodiert und mit einem Zeilenumbruch (code 10) abgeschlossen.</P>
<H4 class="parameter">handle</H4>
<P class="parametersummary">Die Nummer, die vom Open... - Befehl zurückgeben wurde.</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Text, der geschrieben werden soll.</P>
<H2 class="object">LCD</H2>
<P class="objectsummary">Steuert die LCD-Anzeige am Brick.<BR>Der EV3 hat eine schwarz-weiße Anzeige mit 178x128 Pixel. Alle Pixel werden mit X,Y-Koordinaten angesprochen, wobei X=0 der linke Rand und Y=0 der obere Rand ist.</P>
<H3 class="operation">LCD.BmpFile (color, x, y, filename)</H3>
<P class="operationsummary">Zeichnet ein Bild aus einer Datei. Nur Dateien im .rgf-Format werden unterstützt.</P>
<H4 class="parameter">color</H4>
<P class="parametersummary">0 (normal) oder 1 (invertiert)</P>
<H4 class="parameter">x</H4>
<P class="parametersummary">X-Koordinate der linken Kante</P>
<H4 class="parameter">y</H4>
<P class="parametersummary">Y-Koordinate der oberen Kante</P>
<H4 class="parameter">filename</H4>
<P class="parametersummary">Name der Datei ohne die .rgf - Erweiterung. Dieser Dateiname kann relativ zum 'prjs'-Verzeichnis oder ein absoluter Name (mit führendem '/') sein.</P>
<H3 class="operation">LCD.Circle (color, x, y, radius)</H3>
<P class="operationsummary">Zeichnet einen Kreis in einer Farbe.</P>
<H4 class="parameter">color</H4>
<P class="parametersummary">0 (Weiß) oder 1 (Schwarz)</P>
<H4 class="parameter">x</H4>
<P class="parametersummary">X-Koordinate des Mittelpunkts</P>
<H4 class="parameter">y</H4>
<P class="parametersummary">Y-Koordinate des Mittelpunkts</P>
<H4 class="parameter">radius</H4>
<P class="parametersummary">Radius des Kreises</P>
<H3 class="operation">LCD.Clear ()</H3>
<P class="operationsummary">Setzt alle Pixel der Anzeige auf Weiß.</P>
<H3 class="operation">LCD.FillCircle (color, x, y, radius)</H3>
<P class="operationsummary">Füllt einen Kreis mit einer Farbe.</P>
<H4 class="parameter">color</H4>
<P class="parametersummary">0 (Weiß) oder 1 (Schwarz)</P>
<H4 class="parameter">x</H4>
<P class="parametersummary">X-Koordinate des Mittelpunkts</P>
<H4 class="parameter">y</H4>
<P class="parametersummary">Y-Koordinate des Mittelpunkts</P>
<H4 class="parameter">radius</H4>
<P class="parametersummary">Radius des Kreises</P>
<H3 class="operation">LCD.FillRect (color, x, y, width, height)</H3>
<P class="operationsummary">Füllt ein Rechteck mit einer Farbe.</P>
<H4 class="parameter">color</H4>
<P class="parametersummary">0 (Weiß) oder 1 (Schwarz)</P>
<H4 class="parameter">x</H4>
<P class="parametersummary">Linke Kante des Rechtecks</P>
<H4 class="parameter">y</H4>
<P class="parametersummary">Obere Kante des Rechtecks</P>
<H4 class="parameter">width</H4>
<P class="parametersummary">Breite des Rechtecks</P>
<H4 class="parameter">height</H4>
<P class="parametersummary">Höhe des Rechtecks</P>
<H3 class="operation">LCD.InverseRect (x, y, width, height)</H3>
<P class="operationsummary">Invertiert die Farbe aller Pixel innerhalb eines Rechtecks.</P>
<H4 class="parameter">x</H4>
<P class="parametersummary">Linke Kante des Rechtecks</P>
<H4 class="parameter">y</H4>
<P class="parametersummary">Obere Kante des Rechtecks</P>
<H4 class="parameter">width</H4>
<P class="parametersummary">Breite des Rechtecks</P>
<H4 class="parameter">height</H4>
<P class="parametersummary">Höhe des Rechtecks</P>
<H3 class="operation">LCD.Line (color, x1, y1, x2, y2)</H3>
<P class="operationsummary">Zeichnet eine gerade Linie von Pixel mit einer Farbe.</P>
<H4 class="parameter">color</H4>
<P class="parametersummary">0 (Weiß) oder 1 (Schwarz)</P>
<H4 class="parameter">x1</H4>
<P class="parametersummary">X-Koordinate des Startpunkts</P>
<H4 class="parameter">y1</H4>
<P class="parametersummary">Y-Koordinate des Startpunkts</P>
<H4 class="parameter">x2</H4>
<P class="parametersummary">X-Koordinate des Endpunkts</P>
<H4 class="parameter">y2</H4>
<P class="parametersummary">Y-Koordinate des Endpunkts</P>
<H3 class="operation">LCD.Pixel (color, x, y)</H3>
<P class="operationsummary">Setzt die Farbe eines einzelnen Pixels auf der Anzeige.</P>
<H4 class="parameter">color</H4>
<P class="parametersummary">0 (Weiß) oder 1 (Schwarz)</P>
<H4 class="parameter">x</H4>
<P class="parametersummary">X-Koordinate</P>
<H4 class="parameter">y</H4>
<P class="parametersummary">Y-Koordinate</P>
<H3 class="operation">LCD.Rect (color, x, y, width, height)</H3>
<P class="operationsummary">Zeichnet den Umriss eines Rechtecks in einer Farbe.</P>
<H4 class="parameter">color</H4>
<P class="parametersummary">0 (Weiß) oder 1 (Schwarz)</P>
<H4 class="parameter">x</H4>
<P class="parametersummary">Linke Kante des Rechtecks</P>
<H4 class="parameter">y</H4>
<P class="parametersummary">Obere Kante des Rechtecks</P>
<H4 class="parameter">width</H4>
<P class="parametersummary">Breite des Rechtecks</P>
<H4 class="parameter">height</H4>
<P class="parametersummary">Höhe des Rechtecks</P>
<H3 class="operation">LCD.StopUpdate ()</H3>
<P class="operationsummary">Verhindert, dass nachfolgende Ausgabebefehle sofort auf die Anzeige zeichnen und speichert die Änderungen zuerst nur.<BR>Beim nächsten Aufruf von Update werden die Änderungen schließlich auf einmal zur Anzeige gebracht. Dieser Befehl kann nützlich sein, um Bildschirmflackern zu verhindern oder die Ausgabe zu beschleunigen.</P>
<H3 class="operation">LCD.Text (color, x, y, font, text)</H3>
<P class="operationsummary">Schreibt einen Text (oder eine Zahl) in einer Größe und Farbe.</P>
<H4 class="parameter">color</H4>
<P class="parametersummary">0 (Weiß) oder 1 (Schwarz)</P>
<H4 class="parameter">x</H4>
<P class="parametersummary">X-Koordinate, wo der Text anfangen soll</P>
<H4 class="parameter">y</H4>
<P class="parametersummary">Y-Koordinate, wo der Text anfangen soll</P>
<H4 class="parameter">font</H4>
<P class="parametersummary">Schriftgröße: 0 (winzig), 1 (klein), 2 (groß)</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Text (oder die Zahl), die geschrieben werden soll</P>
<H3 class="operation">LCD.Update ()</H3>
<P class="operationsummary">Zeichnet alle Änderungen seit dem letzten StopUpdate auf die Anzeige.<BR>Nach Update() werden wieder alle Änderungen sofort auf die Anzeige gebracht, außer man benutzt StopUpdate ein weiteres mal.</P>
<H3 class="operation">LCD.Write (x, y, text)</H3>
<P class="operationsummary">Schreibt einen Text (oder eine Zahl) in mittlerer Größe und schwarzer Farbe.</P>
<H4 class="parameter">x</H4>
<P class="parametersummary">X-Koordinate, wo der Text anfangen soll</P>
<H4 class="parameter">y</H4>
<P class="parametersummary">Y-Koordinate, wo der Text anfangen soll</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Text (oder die Zahl), die geschrieben werden soll</P>
<H2 class="object">Mailbox</H2>
<P class="objectsummary">Kommunikationsystem um Daten von einem EV3-Brick zu einem anderen über Bluetooth-Funk zu übertragen.</P>
<H3 class="operation">Mailbox.Connect (brickname)</H3>
<P class="operationsummary">Versucht, eine Verbindung zu einem anderen EV3-Brick aufzubauen.<BR>Nur wenn eine Verbindung geöffnet wurde (entweder mit diesem Befehl oder von Hand mit dem Menu am Brick), können Nachrichten ausgetauscht werden.</P>
<H4 class="parameter">brickname</H4>
<P class="parametersummary">Name des anderen Bricks.</P>
<H3 class="operation">Mailbox.Create (boxname)</H3>
<P class="operationsummary">Erzeugt einen Briefkasten für ankommenden Nachrichten auf dem Brick. <BR>Erst wenn solch ein Briefkasten angelegt wurde, können Nachrichten empfangen werden.<BR>Maximal 30 Briefkästen können auf einem Brick existieren.</P>
<H4 class="parameter">boxname</H4>
<P class="parametersummary">Name des neuen Briefkastens</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Eine Identifikationsnummer für den Briefkasten. Sie wird benötigt um später Nachrichten herauszuholen</P>
<H3 class="operation">Mailbox.IsAvailable (id)</H3>
<P class="operationsummary">Prüft, ob bereits eine Nachricht im Briefkasten ist.</P>
<H4 class="parameter">id</H4>
<P class="parametersummary">Identifikationsnummer des lokalen Briefkastens.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">"True", falls bereits eine Nachricht vorliegt. Sonst "False".</P>
<H3 class="operation">Mailbox.Receive (id)</H3>
<P class="operationsummary">Entfernt und holt die älteste Nachricht aus dem Briefkasten. Wenn noch keine Nachricht vorhanden ist, blockiert dieser Befehl so lange, bis eine Nachricht eintrifft.<BR>Wenn man blockierendes Warten vermeiden will, kann man zuvor mit IsAvailable() prüfen, ob eine Nachricht da ist.<BR>Falls gar kein Briefkasten mit der Identifikationsnummer existiert, liefert der Befehl sofort "".</P>
<H4 class="parameter">id</H4>
<P class="parametersummary">Identifikationsnummer des Briefkastens</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Die Nachricht als einfacher Text. Derzeit werden keine anderen Nachrichtenformate unterstützt.</P>
<H3 class="operation">Mailbox.Send (brickname, boxname, message)</H3>
<P class="operationsummary">Sendet eine Nachricht an einen Briefkasten eines anderen EV3-Bricks.</P>
<H4 class="parameter">brickname</H4>
<P class="parametersummary">Der Name des Bricks, der die Nachricht empfangen soll. Zuvor muss eine Verbindung zu diesem Brick geöffnet worden sein. Es ist auch möglich, einen Leertext als Namen anzugeben. In diesem Fall wird die Nachricht an alle verbundenen Bricks geschickt.</P>
<H4 class="parameter">boxname</H4>
<P class="parametersummary">Name des Briefkastens in dem die Nachricht gespeichert werden soll.</P>
<H4 class="parameter">message</H4>
<P class="parametersummary">Die Nachricht als einfacher Text. Derzeit werden keine anderen Nachrichtenformate unterstützt.</P>
<H2 class="object">Math</H2>
<P class="objectsummary">Das Math-Objekt stellt zahlreiche nützliche mathematische Methoden zur Verfügung</P>
<H3 class="property">Math.Pi - Eigenschaft</H3>
<P class="propertysummary">Gibt den Wert der Zahl Pi zurück</P>
<H3 class="operation">Math.Abs (number)</H3>
<P class="operationsummary">Ruft den absoluten Wert einer Zahl ab. Zum Beispiel gibt -32.233 den Wert 32.233 zurück.</P>
<H4 class="parameter">number</H4>
<P class="parametersummary">Die Zahl, für die der absolute Wert abgerufen werden soll.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der absolute Wert einer Zahl.</P>
<H3 class="operation">Math.ArcCos (cosValue)</H3>
<P class="operationsummary">Ermittelt den Bogenmaßwinkel anhand des Kosinuswertes.</P>
<H4 class="parameter">cosValue</H4>
<P class="parametersummary">Der Kosinuswert, dessen Winkel benötigt wird.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der Bogenmaßwinkel für den gegebenen Kosinuswert.</P>
<H3 class="operation">Math.ArcSin (sinValue)</H3>
<P class="operationsummary">Ermittelt den Bogenmaßwinkel anhand des Sinuswertes.</P>
<H4 class="parameter">sinValue</H4>
<P class="parametersummary">Der Sinuswert, dessen Winkel benötigt wird.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der Bogenmaßwinkel für den gegebenen Sinuswert.</P>
<H3 class="operation">Math.ArcTan (tanValue)</H3>
<P class="operationsummary">Ermittelt den Bogenmaßwinkel anhand des Tangenswertes.</P>
<H4 class="parameter">tanValue</H4>
<P class="parametersummary">Der Tangenswert, dessen Winkel benötigt wird.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der Bogenmaßwinkel für den gegebenen Tangenswert.</P>
<H3 class="operation">Math.Ceiling (number)</H3>
<P class="operationsummary">Ruft eine Ganzzahl ab, die den gleichen Wert wie die angegebene Dezimalzahl hat oder größer als diese ist. Zum Beispiel gibt 32.233 den Wert 33 zurück.</P>
<H4 class="parameter">number</H4>
<P class="parametersummary">Die Zahl, deren größter Wert erforderlich ist.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der größte Wert einer Zahl.</P>
<H3 class="operation">Math.Cos (angle)</H3>
<P class="operationsummary">Ermittelt den Kosinus des angegebenen Winkels im Bogenmaß.</P>
<H4 class="parameter">angle</H4>
<P class="parametersummary">Der Winkel (im Bogenmaß), dessen Kosinus benötigt wird.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der Kosinus des gegebenen Winkels.</P>
<H3 class="operation">Math.Floor (number)</H3>
<P class="operationsummary">Ruft eine Ganzzahl ab, die den gleichen Wert wie die angegebene Dezimalzahl hat oder kleiner als diese ist. Zum Beispiel gibt 32.233 den Wert 32 zurück.</P>
<H4 class="parameter">number</H4>
<P class="parametersummary">Die Zahl, deren kleinster Wert erforderlich ist.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der kleinste Wert einer Zahl.</P>
<H3 class="operation">Math.GetDegrees (angle)</H3>
<P class="operationsummary">Rechnet einen Winkel im Bogenmaß in Gradmaß um.</P>
<H4 class="parameter">angle</H4>
<P class="parametersummary">Der Winkel im Bogenmaß.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der umgewandelte Winkel in Grad.</P>
<H3 class="operation">Math.GetRadians (angle)</H3>
<P class="operationsummary">Rechnet einen Winkel im Gradmaß in Bogenmaß um.</P>
<H4 class="parameter">angle</H4>
<P class="parametersummary">Der Winkel in Grad.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der umgewandelte Winkel im Bogenmaß.</P>
<H3 class="operation">Math.GetRandomNumber (maxNumber)</H3>
<P class="operationsummary">Liefert eine Zufallszahl zwischen 1 und der gegebenen Zahl (inklusive).</P>
<H4 class="parameter">maxNumber</H4>
<P class="parametersummary">Die Obergrenze für die angeforderte Zufallszahl.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Eine Zufallszahl die kleiner oder gleich der spezifiziert Zahl ist.</P>
<H3 class="operation">Math.Log (number)</H3>
<P class="operationsummary">Ermittelt den Logarithmus zur Basis 10 der angegebenen Zahl.</P>
<H4 class="parameter">number</H4>
<P class="parametersummary">Die Zahl, deren Logarithmus ermittelt werden soll.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der Logarithmus der angegebenen Zahl</P>
<H3 class="operation">Math.Max (number1, number2)</H3>
<P class="operationsummary">Vergleicht zwei Zahlen und gibt die größere der beiden zurück.</P>
<H4 class="parameter">number1</H4>
<P class="parametersummary">Die erste von zwei zu vergleichenden Zahlen.</P>
<H4 class="parameter">number2</H4>
<P class="parametersummary">Die zweite von zwei zu vergleichenden Zahlen.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Die Größere der zwei Zahlen.</P>
<H3 class="operation">Math.Min (number1, number2)</H3>
<P class="operationsummary">Vergleicht zwei Zahlen und gibt die kleinere der beiden zurück.</P>
<H4 class="parameter">number1</H4>
<P class="parametersummary">Die Erste von zwei zu vergleichenden Zahlen.</P>
<H4 class="parameter">number2</H4>
<P class="parametersummary">Die Zweite von zwei zu vergleichenden Zahlen.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Die Kleinere der zwei Zahlen.</P>
<H3 class="operation">Math.NaturalLog (number)</H3>
<P class="operationsummary">Ermittelt den natürlichen Logarithmus der angegebenen Zahl.</P>
<H4 class="parameter">number</H4>
<P class="parametersummary">Die Zahl, deren natürlicher Logarithmuswert erforderlich ist.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der natürliche Logarithmuswert einer Zahl.</P>
<H3 class="operation">Math.Power (baseNumber, exponent)</H3>
<P class="operationsummary">Berechnet die angegebene Potenz der Zahl baseNumber.</P>
<H4 class="parameter">baseNumber</H4>
<P class="parametersummary">Die Zahl, deren Potenz berechnet werden soll.</P>
<H4 class="parameter">exponent</H4>
<P class="parametersummary">Der Exponent, der bei der Berechnung der Potenz verwendet werden soll.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Die angebenene Potenz der Zahl baseNumber.</P>
<H3 class="operation">Math.Remainder (dividend, divisor)</H3>
<P class="operationsummary">Teilt die erste Zahl durch die zweite Zahl und gibt den Rest zurück.</P>
<H4 class="parameter">dividend</H4>
<P class="parametersummary">Die zu teilende Zahl.</P>
<H4 class="parameter">divisor</H4>
<P class="parametersummary">Die Zahl durch die geteilt werden soll.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der Divisionsrest.</P>
<H3 class="operation">Math.Round (number)</H3>
<P class="operationsummary">Rundet eine gegebene Zahl auf die nächstliegende ganze Zahl. Die Zahl 32.233 wird zum Beispiel auf 32.0 abgerundet, während <BR>32.566 auf 33 aufgerundet wird.</P>
<H4 class="parameter">number</H4>
<P class="parametersummary">Die Zahl dessen Näherungswert benötigt wird.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der gerundete Wert der gegebenen Zahl.</P>
<H3 class="operation">Math.Sin (angle)</H3>
<P class="operationsummary">Ermittelt den Sinus des angegebenen Winkels im Bogenmaß.</P>
<H4 class="parameter">angle</H4>
<P class="parametersummary">Der Winkel (im Bogenmaß), dessen Sinus ermittelt werden soll</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der Sinus des angegebenen Winkels</P>
<H3 class="operation">Math.SquareRoot (number)</H3>
<P class="operationsummary">Ermittelt die Quadratwurzel einer angegebenen Zahl.</P>
<H4 class="parameter">number</H4>
<P class="parametersummary">Die Zahl dessen Quadratwurzel benötigt wird.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Die Quadratwurzel der gegebenen Zahl.</P>
<H3 class="operation">Math.Tan (angle)</H3>
<P class="operationsummary">Ermittelt den Tangens des angegebenen Winkels im Bogenmaß.</P>
<H4 class="parameter">angle</H4>
<P class="parametersummary">Der Winkel (im Bogenmaß), dessen Tangens benötigt wird.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der Tangens des gegebenen Winkels.</P>
<H2 class="object">Motor</H2>
<P class="objectsummary">Steuert die angeschlossenen Motoren.<BR>Bei jedem Befehl muss man einen oder mehrere Motor-Ports angeben, auf den sich der Befehl beziehen soll (zum Beispiel, "A", "BC", "ABD").<BR>Falls weitere EV3-Bricks über ein Kabel mit dem Haupt-Brick verbunden sind, muss man eine Ziffer entsprechend der Stelle in der Kette hinzufügen (z.B. "3BC", "2A"). In diesem Fall kann man mit einem Befehl nur die Motoren eines einzelnen Bricks ansprechen.<BR>Geschwindigkeit oder Leistung: Wenn man einen Motor mit einer gewählten Geschwindigkeit betreiben will, dann reguliert der EV3 die Leistung für den Motor permanent so, dass die Geschwindikgkeit eingehalten wird, egal wie viel Widerstand dem entgegenwirkt (zumindest so lange noch genug Leistungsreserve verfügbar ist).</P>
<H3 class="operation">Motor.GetCount (port)</H3>
<P class="operationsummary">Fragt den aktuellen Rotationszähler eines Motors ab.<BR>So lange der Zähler nicht zurückgesetzt wird, misst er alle Bewegungen eines Motors, auch wenn der Motor durch externe Kräfte bewegt wird, während er nicht aktiv läuft.</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Name des Motor-Ports</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der aktuelle Wert des Rotationszählers.</P>
<H3 class="operation">Motor.GetSpeed (port)</H3>
<P class="operationsummary">Fragt die derzeitige Geschwindigkeit eines Motors ab.</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Motor port name</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Aktuelle Geschwindigkeit im Bereich -100 bis 100</P>
<H3 class="operation">Motor.IsBusy (ports)</H3>
<P class="operationsummary">Prüft, ob einer oder mehrere Motoren gerade aktiv laufen.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name des/der Motor-Ports</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">"True" wenn zumindest einer der Motoren läuft.</P>
<H3 class="operation">Motor.Move (ports, speed, degrees, brake)</H3>
<P class="operationsummary">Bewegt einen oder mehrere Motoren mit der gewählten Geschindigkeit den angegebenen Winkel weit.<BR>Dieser Befehl blockiert so lange, bis die Bewegung abgeschlossen ist.<BR>Für eine feinere Kontrolle über die Bewegung kann man statt dessen auch Motor.Schedule verwenden.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name des/der Motor-Ports</P>
<H4 class="parameter">speed</H4>
<P class="parametersummary">Geschwindigkeit von -100 (maximal rückwärts) bis 100 (maximal vorwärts).</P>
<H4 class="parameter">degrees</H4>
<P class="parametersummary">Der Winkel den der Motor drehen soll</P>
<H4 class="parameter">brake</H4>
<P class="parametersummary">"True", wenn die Motoren die elektrische Bremse benutzen sollen.</P>
<H3 class="operation">Motor.MovePower (ports, power, degrees, brake)</H3>
<P class="operationsummary">Bewegt einen oder mehrere Motoren mit der gewählten Leistung den angegebenen Winkel weit.<BR>Dieser Befehl blockiert so lange, bis die Bewegung abgeschlossen ist.<BR>Für eine feinere Kontrolle über die Bewegung kann man statt dessen auch Motor.SchedulePower verwenden.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name des/der Motor-Ports</P>
<H4 class="parameter">power</H4>
<P class="parametersummary">Leistung von -100 (maximal rückwärts) bis 100 (maximal vorwärts).</P>
<H4 class="parameter">degrees</H4>
<P class="parametersummary">Der Winkel den der Motor drehen soll</P>
<H4 class="parameter">brake</H4>
<P class="parametersummary">"True", wenn die Motoren die elektrische Bremse benutzen sollen.</P>
<H3 class="operation">Motor.MoveSync (ports, speed1, speed2, degrees, brake)</H3>
<P class="operationsummary">Dreht 2 Motoren synchronisiert einen gewünschten Winkel weit.<BR>Synchronisiert bedeutet, dass die Regelung immer versucht, das Geschwindigkeitsverhältnis beizubehalten, auch wenn ein Motor gebremst wird. In diesem Fall wird der zweite Motor automatisch auch langsamer. Das ist besonders nützlich für ein Fahrzeug mit mit unabhängig angetriebenen Rädern, das aber trotzdem gerade oder eine definierte Kurve fahren soll.<BR>Der Winkel für die Gesamtrotation wird immer beim Motor mit der höheren Geschwindigkeit gemessen.<BR>Dieser Befehl blockiert so lange bis die Bewegung abgeschlossen ist.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name der beiden Motor-Ports</P>
<H4 class="parameter">speed1</H4>
<P class="parametersummary">Geschwindigkeit von -100 (maximal rückwärts) bis 100 (maximal vorwärts) des Motors mit dem niedrigeren Port-Namen (A vor B, etc.).</P>
<H4 class="parameter">speed2</H4>
<P class="parametersummary">Geschwindigkeit von -100 (maximal rückwärts) bis 100 (maximal vorwärts) des Motors mit dem höheren Port-Namen (A vor B, etc.).</P>
<H4 class="parameter">degrees</H4>
<P class="parametersummary">Der Winkel, den der schnellere Motor zurücklegen soll</P>
<H4 class="parameter">brake</H4>
<P class="parametersummary">"True", wenn die Motoren die elektrische Bremse benutzen sollen.</P>
<H3 class="operation">Motor.ResetCount (ports)</H3>
<P class="operationsummary">Setzen den Rotationszähler eines oder mehrerer Motoren auf 0 zurück.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name des/der Motor-Ports</P>
<H3 class="operation">Motor.Schedule (ports, speed, degrees1, degrees2, degrees3, brake)</H3>
<P class="operationsummary">Bewegt einen oder mehrere Motoren entsprechend mehrerer Geschwindigkeits-Parameter. Die Geschwindkeit kann positionsabhängig gesteigert oder verringert werden, um einen sanften Anlauf oder Stopp zu erreichen.<BR>Der Gesamtwinkel, den der Motor drehen soll, ist degrees1+degrees2+degrees3. Am Ende der Bewegung stoppt der Motor automatisch (mit oder ohne Bremsen).<BR>Dieses Kommand kehrt sofort zurück, während der Motor noch läuft. Mit IsBusy() kann man testen, wann die Bewegung abgeschlossen ist, oder das Programm kann mit Wait() direkt auf das Ende warten.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name des/der Motor-Ports</P>
<H4 class="parameter">speed</H4>
<P class="parametersummary">Geschwindigkeit von -100 (maximal rückwärts) bis 100 (maximal vorwärts).</P>
<H4 class="parameter">degrees1</H4>
<P class="parametersummary">Der Teil der Rotation für die Beschleunigung</P>
<H4 class="parameter">degrees2</H4>
<P class="parametersummary">Der Teil der Rotation in gleichmäßiger Bewegung</P>
<H4 class="parameter">degrees3</H4>
<P class="parametersummary">Der Teil der Rotation für das Abbremsen</P>
<H4 class="parameter">brake</H4>
<P class="parametersummary">"True", wenn der Motor die elektrische Bremse benutzen soll.</P>
<H3 class="operation">Motor.SchedulePower (ports, power, degrees1, degrees2, degrees3, brake)</H3>
<P class="operationsummary">Bewegt einen oder mehrere Motoren entsprechend mehrerer Leistungs-Parameter. Die Leistung kann positionsabhängig gesteigert oder verringert werden, um einen sanften Anlauf oder Stopp zu erreichen.<BR>Der Gesamtwinkel den der Motor drehen soll, ist degrees1+degrees2+degrees3. Am Ende der Bewegung stoppt der Motor automatisch (mit oder ohne Bremsen).<BR>Dieses Kommand kehrt sofort zurück, während der Motor noch läuft. Mit IsBusy() kann man testen, wann die Bewegung abgeschlossen ist, oder das Programm kann mit Wait() direkt auf das Ende warten.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name des/der Motor-Ports</P>
<H4 class="parameter">power</H4>
<P class="parametersummary">Leistung von -100 (maximal rückwärts) bis 100 (maximal vorwärts).</P>
<H4 class="parameter">degrees1</H4>
<P class="parametersummary">Der Teil der Rotation für die Beschleunigung</P>
<H4 class="parameter">degrees2</H4>
<P class="parametersummary">Der Teil der Rotation in gleichmäßiger Bewegung</P>
<H4 class="parameter">degrees3</H4>
<P class="parametersummary">Der Teil der Rotation für das Abbremsen</P>
<H4 class="parameter">brake</H4>
<P class="parametersummary">"True", wenn der Motor die elektrische Bremse benutzen soll.</P>
<H3 class="operation">Motor.ScheduleSync (ports, speed1, speed2, degrees, brake)</H3>
<P class="operationsummary">Dreht 2 Motoren synchronisiert einen gewünschten Winkel weit.<BR>Synchronisiert bedeutet, dass die Regelung immer versucht, das Geschwindigkeitsverhältnis beizubehalten, auch wenn ein Motor gebremst wird. In diesem Fall wird der zweite Motor automatisch auch langsamer. Das ist besonders nützlich für Fahrzeuge mit unabhängig angetriebenen Rädern, die aber trotzdem gerade oder eine definierte Kurve fahren sollen.<BR>Der Winkel für die Gesamtrotation wird immer beim Motor mit der höheren Geschwindigkeit gemessen.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name der beiden Motor-Ports</P>
<H4 class="parameter">speed1</H4>
<P class="parametersummary">Geschwindigkeit von -100 (maximal rückwärts) bis 100 (maximal vorwärts) des Motors mit dem niedrigeren Port-Namen (A vor B, etc.).</P>
<H4 class="parameter">speed2</H4>
<P class="parametersummary">Geschwindigkeit von -100 (maximal rückwärts) bis 100 (maximal vorwärts) des Motors mit dem höheren Port-Namen (A vor B, etc.).</P>
<H4 class="parameter">degrees</H4>
<P class="parametersummary">Der Winkel, den der schnellere Motor zurücklegen soll</P>
<H4 class="parameter">brake</H4>
<P class="parametersummary">"True", wenn die Motoren die elektrische Bremse benutzen sollen.</P>
<H3 class="operation">Motor.Start (ports, speed)</H3>
<P class="operationsummary">Startet einen oder mehrere Motoren mit der gewählten Geschwindigkeit oder setzt die Geschwindigkeit neu fest.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name des/der Motor-Ports</P>
<H4 class="parameter">speed</H4>
<P class="parametersummary">Geschwindigkeit von -100 (maximal rückwärts) bis 100 (maximal vorwärts).</P>
<H3 class="operation">Motor.StartPower (ports, power)</H3>
<P class="operationsummary">Startet einen oder mehrere Motoren mit der angegebenen Leistung.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name des/der Motor-Ports</P>
<H4 class="parameter">power</H4>
<P class="parametersummary">Leistung von -100 (maximal rückwärts) bis 100 (maximal vorwärts).</P>
<H3 class="operation">Motor.StartSync (ports, speed1, speed2)</H3>
<P class="operationsummary">Startet zwei Motoren, die synchronisiert mit jeweils einstellbaren Geschwindigkeiten laufen.<BR>Synchronisiert bedeutet, dass die Regelung immer versucht, das Geschwindigkeitsverhältnis beizubehalten, auch wenn ein Motor gebremst wird. In diesem Fall wird der zweite Motor automatisch auch langsamer. Das ist besonders nützlich für Fahrzeuge mit mit unabhängig angetriebenen Rädern, das aber trotzdem gerade oder eine definierte Kurve fahren soll.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name der beiden Motor-Ports</P>
<H4 class="parameter">speed1</H4>
<P class="parametersummary">Geschwindigkeit von -100 (maximal rückwärts) bis 100 (maximal vorwärts) des Motors mit dem niedrigeren Port-Namen (A vor B, etc.).</P>
<H4 class="parameter">speed2</H4>
<P class="parametersummary">Geschwindigkeit von -100 (maximal rückwärts) bis 100 (maximal vorwärts) des Motors mit dem höheren Port-Namen (A vor B, etc.).</P>
<H3 class="operation">Motor.Stop (ports, brake)</H3>
<P class="operationsummary">Stoppt einen oder mehrere Motoren.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name des/der Motor-Ports</P>
<H4 class="parameter">brake</H4>
<P class="parametersummary">"True", wenn der Motor die elektrische Bremse benutzen soll.</P>
<H3 class="operation">Motor.Wait (ports)</H3>
<P class="operationsummary">Wartet bis ein oder mehrere Motoren ihre Bewegung abgeschlossen habe.			<BR>Dieses Kommando zu benutzen ist normalerweise besser als IsBusy() in einer Schleife abzufragen.</P>
<H4 class="parameter">ports</H4>
<P class="parametersummary">Name des/der Motor-Ports</P>
<H2 class="object">Program</H2>
<P class="objectsummary">Die Klasse 'Program' enthält Hilfsfunktionen, um die Ausführung von Programmen zu kontrollieren.</P>
<H3 class="property">Program.ArgumentCount - Eigenschaft</H3>
<P class="propertysummary">Ruft die Anzahl der Befehlszeilenargumente ab, die an das Programm übergeben wurden.</P>
<H3 class="property">Program.Directory - Eigenschaft</H3>
<P class="propertysummary">Liefert das Verzeichnis des laufenden Programms.</P>
<H3 class="operation">Program.Delay (milliSeconds)</H3>
<P class="operationsummary">Verzögert die Ausführung eines Programms um die angegebene Anzahl Millisekunden (MilliSeconds).</P>
<H4 class="parameter">milliSeconds</H4>
<P class="parametersummary">Die Verzögerung.</P>
<H3 class="operation">Program.End ()</H3>
<P class="operationsummary">Beendet das Programm.</P>
<H3 class="operation">Program.GetArgument (index)</H3>
<P class="operationsummary">Gibt das Argument zurück, das an das Programm übergeben wurde.</P>
<H4 class="parameter">index</H4>
<P class="parametersummary">Der Index des Arguments.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Das Befehlszeilenargument am angegebenen Index.</P>
<H2 class="object">Sensor</H2>
<P class="objectsummary">Steuert die angeschlossenen Sensoren.<BR>Um einen Sensor-Port zu adressieren, verwendet man die Portnummer, die unterhalb des Ports aufgedruckt ist (z.B. 1). Um Ports anderer EV3-Bricks, die mit dem Haupt-Brick verbunden sind, anzusprechen, verwendet man die nächst höheren Nummern (5 - 8 für die Sensor-Ports des ersten angeschlossenen Bricks, 9-12 für die des nächsten, und so weiter).</P>
<H3 class="operation">Sensor.CommunicateI2C (port, address, writebytes, readbytes, writedata)</H3>
<P class="operationsummary">Kommuniziert mit Geräten (nicht unbedingt nur Sensoren), die an einem Sensor-Port angeschlossen sind und das I2C-Protokoll verwenden.<BR>Dieser Befehl adressiert ein Gerät am I2C-bus und kann mehrere Bytes senden und empfangen. <BR>Achtung: Dieser Befehl funktioniert nicht bei EV3-Bricks, die an einem Haupt-Brick angeschlossen und von diesem gesteuert werden.</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Nummer des Sensor-Ports</P>
<H4 class="parameter">address</H4>
<P class="parametersummary">Adresse (0 - 127) des I2C-Slaves am I2C-Bus</P>
<H4 class="parameter">writebytes</H4>
<P class="parametersummary">Anzahl der Bytes, die gesendet werden sollen (maximal 31).</P>
<H4 class="parameter">readbytes</H4>
<P class="parametersummary">Anzahl der Bytes, die empfangen werden sollen (maximal 32, minimal 1).</P>
<H4 class="parameter">writedata</H4>
<P class="parametersummary">Array mit den zu sendenden Bytes.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Ein Array mit den empfangenen Bytes.</P>
<H3 class="operation">Sensor.GetMode (port)</H3>
<P class="operationsummary">Liest den aktuellen Modus des Sensors.<BR>Viele Sensoren können in sehr verschiedenen Modi arbeiten und sehr unterschiedliche Werte liefern. Zum Beispiel kann der Farbsensor entweder das Umgebungslicht oder reflektiertes Licht, oder die Farbe einer Oberfläche messen. Sobald ein Sensor eingesteckt ist, startet er normalerweise mit Modus 0, kann aber später vom Programm in einen anderen Modus versetzt werden.</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Nummer des Sensor-Ports</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Aktuelle Modus (0 ist immer der Anfangs-Modus)</P>
<H3 class="operation">Sensor.GetName (port)</H3>
<P class="operationsummary">Liest den Namen und den Modus eines gerade angeschlossenen Sensors.<BR>Dieser Befehl ist hauptsächlich für Diagnosen nützlich, weil das Programm normalerweise implizit weiß, welche Sensorsen angeschlossen sind.</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Nummer des Sensor-Ports</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Lesbarer Text mit Port und Modus(z.B. "TOUCH")</P>
<H3 class="operation">Sensor.GetType (port)</H3>
<P class="operationsummary">Liest die Identificationsnummer des Sensors.</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Nummer des Sensor-Ports</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Identificationsnummer (z.B. für einen Tastsensor)</P>
<H3 class="operation">Sensor.IsBusy (port)</H3>
<P class="operationsummary">Prüft, ob ein Sensor gerade mit einem Moduswechsel beschäftigt ist. Nach Umschaltung kann es einige Zeit dauern, bevor neue Messergebnisse vorliegen.</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Nummer des Sensor-Ports</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">"True", wenn der Sensor gerade noch beschäftigt ist</P>
<H3 class="operation">Sensor.ReadPercent (port)</H3>
<P class="operationsummary">Liest einen einzelnen Wert und rechnet ihn in eine sinnvolle Prozentangabe um.<BR>Viele Sensoren können ihre gelesenen Werte in einen einzelnen Wert umrechnen, wie z.B. Lichtintenität oder den Zustand eines Tastknopfes.</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Nummer des Sensor-Ports</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der Prozentwert des gemessenen Werts (z.B.: Ein Tastsensor liefert immer 100 wenn gedrückt, und 0 wenn nicht gedrückt)</P>
<H3 class="operation">Sensor.ReadRaw (port, values)</H3>
<P class="operationsummary">Liest einen Sensorwert wenn das Ergebnis von ReadPercent() nicht ausreichend ist.<BR>Manche Sensoren liefern Werte, die nicht in Prozent ausgedrückt werden können (z.B. ein Farb-Index) oder die aus mehreren Werten auf einmal bestehen (z.B. Entfernung und Richtung des Infrarot-Peilsenders).</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Nummer des Sensor-Ports</P>
<H4 class="parameter">values</H4>
<P class="parametersummary">Anzahl der Werte-Komponenten</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Ein Array mit der geforderten Anzahl an Komponenten. Der Index beginnt bei 0. Komponenten, für die der Sensor keinen Wert liefert, werden auf 0 gesetzt.</P>
<H3 class="operation">Sensor.SendUARTData (port, writebytes, writedata)</H3>
<P class="operationsummary">Sendet Daten an Geräte, die über den UART an einen Sensor-Port angeschlossen sind.<BR>Das kann nützlich sein, um verschiedene Spezialkommandos zu einem Sensor/Aktor zu schicken.</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Nummer des Sensor-Ports</P>
<H4 class="parameter">writebytes</H4>
<P class="parametersummary">Anzahl der zu sendenden Bytes (maximum 32).</P>
<H4 class="parameter">writedata</H4>
<P class="parametersummary">Array mit den Bytes.</P>
<H3 class="operation">Sensor.SetMode (port, mode)</H3>
<P class="operationsummary">Schaltet einen Sensor in einen anderen Modus.<BR>Viele Sensoren können in unterschiedlichen Modi arbeiten und sehr verschiedene Messergebnisse liefern. Die Bedeuting der Modus-Nummer hängt vom Sensor-Typ ab. Weitere Informationen dazu sind im Anhang zu finden.</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Nummer des Sensor-Ports</P>
<H4 class="parameter">mode</H4>
<P class="parametersummary">Der Modus, in den umgeschaltet werden soll. Das funktioniert nur, wenn der Sensor diesen Modus auch unterstützt.</P>
<H3 class="operation">Sensor.Wait (port)</H3>
<P class="operationsummary">Wartet, bis ein Sensor seinen Moduswechsel abgeschlossen hat. Wenn kein Sensor am angegebenen Port angeschlossen ist, kehrt der Befehl sofort zurück.</P>
<H4 class="parameter">port</H4>
<P class="parametersummary">Nummer des Sensor-Ports</P>
<H2 class="object">Speaker</H2>
<P class="objectsummary">Der eingebaute Lautsprecher des Bricks kann einfache Töne oder Geräuscheffekte abspielen.</P>
<H3 class="operation">Speaker.IsBusy ()</H3>
<P class="operationsummary">Prüft, ob der Lautsprecher noch einen Ton oder einen Geräuscheffekt abspielt.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">"True", wenn noch etwas gespielt wird, sonst "False".</P>
<H3 class="operation">Speaker.Note (volume, note, duration)</H3>
<P class="operationsummary">Beginnt einen Ton zu spielen, der durch eine Text-Beschreibung definiert ist.</P>
<H4 class="parameter">volume</H4>
<P class="parametersummary">Lautstärke im Bereich 0 - 100</P>
<H4 class="parameter">note</H4>
<P class="parametersummary">Text-Beschreibung einer Note "C4"  "B7" oder eines Halbtones wie "C#5"</P>
<H4 class="parameter">duration</H4>
<P class="parametersummary">Dauer des Tones in Millisekunden</P>
<H3 class="operation">Speaker.Play (volume, filename)</H3>
<P class="operationsummary">Spielt einen Geräuscheffekt aus einer am Brick gespeicherten Datei. Derzeit werden nur Dateien im .rsf - Format unterstützt.</P>
<H4 class="parameter">volume</H4>
<P class="parametersummary">Lautstärke im Bereich 0 - 100</P>
<H4 class="parameter">filename</H4>
<P class="parametersummary">Name der Datei ohne die .rsf - Erweiterung. Dieser Dateiname kann relativ zum 'prjs'-Verzeichnis oder ein absoluter Pfadname sein (mit führendem '/').</P>
<H3 class="operation">Speaker.Stop ()</H3>
<P class="operationsummary">Stoppt jeden gerade laufenden Ton oder Geräuscheffekt..</P>
<H3 class="operation">Speaker.Tone (volume, frequency, duration)</H3>
<P class="operationsummary">Beginnt einen Ton der angegebenen Frequenz zu spielen.</P>
<H4 class="parameter">volume</H4>
<P class="parametersummary">Lautstärke im Bereich 0 - 100</P>
<H4 class="parameter">frequency</H4>
<P class="parametersummary">Frequenz in Hz im Bereich 250 - 10000</P>
<H4 class="parameter">duration</H4>
<P class="parametersummary">Dauer des Tones in Millisekunden</P>
<H3 class="operation">Speaker.Wait ()</H3>
<P class="operationsummary">Wartet bis der gerade gespielte Ton/Geräuscheffekt fertig ist.</P>
<H2 class="object">Text</H2>
<P class="objectsummary">Das Text-Objekt bietet nützliche Vorgänge für das Arbeiten mit Text.</P>
<H3 class="operation">Text.Append (text1, text2)</H3>
<P class="operationsummary">Fügt zwei Texteingaben zusammen und gibt das Resultat als einen neuen Text zurück. Dieser Vorgang ist besonders dann nützlich, wenn man unbekannten Text in Variablen verarbeitet, der versehentlich als Zahl behandelt und addiert werden könnte, anstelle zusammengefügt zu werden.</P>
<H4 class="parameter">text1</H4>
<P class="parametersummary">Der erste Teil des zu verknüpfenden Textes.</P>
<H4 class="parameter">text2</H4>
<P class="parametersummary">Der zweite Teil des zu verknüpfenden Textes.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der verknüpfte Text mit beiden Bestandteilen.</P>
<H3 class="operation">Text.ConvertToLowerCase (text)</H3>
<P class="operationsummary">Konvertiert den Textteil in kleine Buchstaben.</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Text, der in Kleinbuchstaben umgewandelt werden soll.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der angegebene Text in Kleinbuchstaben.</P>
<H3 class="operation">Text.ConvertToUpperCase (text)</H3>
<P class="operationsummary">Konvertiert den Textteil in Großbuchstaben.</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Text, der in Großbuchstaben umgewandelt werden soll.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der angegebene Text in Großbuchstaben.</P>
<H3 class="operation">Text.EndsWith (text, subText)</H3>
<P class="operationsummary">Ruft ab, ob ein bestimmter Textabschnitt mit dem angegebenen Textteil endet.</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Textabschnitt, in dem gesucht werden soll.</P>
<H4 class="parameter">subText</H4>
<P class="parametersummary">Die gesuchte Zeichenfolge.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">True, wenn die Zeichenfolge am Ende des Textes gefunden wurde.</P>
<H3 class="operation">Text.GetCharacter (characterCode)</H3>
<P class="operationsummary">Je nach Unicode-Zeichencode wird das entsprechende Zeichen abgerufen, das dann als normaler Text verwendet werden kann.</P>
<H4 class="parameter">characterCode</H4>
<P class="parametersummary">Der Unicode-Zeichencode für ein bestimmtes Zeichen.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Das Unicode-Zeichen, das dem Unicode-Zeichencode entspricht.</P>
<H3 class="operation">Text.GetCharacterCode (character)</H3>
<P class="operationsummary">Wird ein Unicode-Zeichen eingegeben, wird der entsprechende Unicode-Zeichencode abgerufen.</P>
<H4 class="parameter">character</H4>
<P class="parametersummary">Das Zeichen, für das der Zeichencode abgerufen werden soll.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der Unicode-Zeichencode, der dem angegebenen Zeichen entspricht.</P>
<H3 class="operation">Text.GetIndexOf (text, subText)</H3>
<P class="operationsummary">Sucht die Position einer Zeichenfolge innerhalb eines angegebenen Textes.</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Text, in dem gesucht werden soll.</P>
<H4 class="parameter">subText</H4>
<P class="parametersummary">Der zu suchende Text.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Die Position, an der das Textsegment im angegebenen Text erscheint. Wenn der Text nicht erscheint, wird 0 zurückgegeben.</P>
<H3 class="operation">Text.GetLength (text)</H3>
<P class="operationsummary">Ruft die Länge des Textes ab.</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Text, dessen Länge benötigt wird.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Die Länge eines angegebenen Textes.</P>
<H3 class="operation">Text.GetSubText (text, start, length)</H3>
<P class="operationsummary">Ruft einen Textteil aus einem größeren Textabschnitt ab.</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Text, dem die Zeichenfolge entnommen werden soll.</P>
<H4 class="parameter">start</H4>
<P class="parametersummary">Bestimmt, wo angefangen werden soll.</P>
<H4 class="parameter">length</H4>
<P class="parametersummary">Bestimmt die Länge einer Zeichenfolge.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Der angeforderte Textteil</P>
<H3 class="operation">Text.GetSubTextToEnd (text, start)</H3>
<P class="operationsummary">Ruft eine Zeichenfolge innerhalb eines Textes ab, angefangen bei einer bestimmten Position bis zum Ende.</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Text, dem die Zeichenfolge entnommen werden soll.</P>
<H4 class="parameter">start</H4>
<P class="parametersummary">Bestimmt, wo angefangen werden soll.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Die angeforderte Zeichenfolge.</P>
<H3 class="operation">Text.IsSubText (text, subText)</H3>
<P class="operationsummary">Ruft ab, ob ein Textteil ein Bestandteil eines größeren Textabschnittes ist.</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Textabschnitt, in dem die Zeichenfolge gesucht werden soll.</P>
<H4 class="parameter">subText</H4>
<P class="parametersummary">Die gesuchte Zeichenfolge.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">True, wenn die Zeichenfolge im angegebenen Text gefunden wurde.</P>
<H3 class="operation">Text.StartsWith (text, subText)</H3>
<P class="operationsummary">Ruft ab, ob ein bestimmter Textabschnitt mit dem angegebenen Textteil beginnt.</P>
<H4 class="parameter">text</H4>
<P class="parametersummary">Der Textabschnitt, in dem gesucht werden soll.</P>
<H4 class="parameter">subText</H4>
<P class="parametersummary">Die gesuchte Zeichenfolge.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">True, wenn die Zeichenfolge zu Beginn des Textes gefunden wurde.</P>
<H2 class="object">Thread</H2>
<P class="objectsummary">Dieses Objekt unterstützt die Verwendung von Nebenläufigkeiten (Threads) in einem Programm.<BR>Ein Thread ist ein Programmstück, das unabhängig von und gleichzeitig mit anderen Teilen des Programmes ablaufen kann. Zum Beispiel könnte ein Thread die Motoren einer Maschine steuern, während ein anderer Thread Tasteneingaben verarbeitet.<BR>Allgemein gesagt ist Multithreading ein sehr komplexes Thema. Um es wirklich zu verstehen, empfehle ich die Verwendung weiterführender Literatur.</P>
<H3 class="property">Thread.Run - Eigenschaft</H3>
<P class="propertysummary">Mit dieser Objekt-Eigenschaft werden neue Threads erzeugt. Sobald dieser Eigenschaft ein Unterprogram zugewiesen wird, startet dieses Unterprogramm als unabhängiger Thread (zum Beispiel: Thread.Run = MYSUB). <BR>Jedes Unterprogramm kann so als unabhängiger Thread gestartet werden, aber jedes Unterprogramm kann nur einmal zur gleichen Zeit ablaufen. Eine neuerliche Zuweisung zu Thread.Run(), während das Unterprogram noch als Thread läuft, fügt es nur in eine Warteschlange hinzu.<BR>Sobald sich der vorige Thread beendet (Unterprogram läuft zu seinem Ende), wird es automatisch ein weiteres Mal gestartet. Es gehen keine Aufrufe verloren, aber sie werden eventuell erst später abgearbeitet, als gedacht.<BR>Achtung: Auch wenn noch weitere Threads aktiv sind, wird das ganze Programm terminiert, sobald das Hauptprogramm zu seinem Ende läuft.</P>
<H3 class="operation">Thread.CreateMutex ()</H3>
<P class="operationsummary">Erzeugt einen Mutex (kurz für "Mutual Exclusion" = "gegenseiter Ausschluss") der dann für die Synchronisierung von Threads benutzt werden kann.<BR>Nur die Erzeugung von Mutexes wird unterstützt aber kein Löschen. Idealerweise legt ein Programm alle nötigen Mutexe gleich beim Programmstart an und speichert die Identifikationsnummern in globalen Variablen.</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Die Identifikationsnummer des neue erzeugten Mutex.</P>
<H3 class="operation">Thread.Lock (mutex)</H3>
<P class="operationsummary">Versucht, den Mutex exklusiv für diesen Thread zu sperren, sodass kein anderer Thread darauf zugreifen kann.<BR>Falls ein anderer Thread bereits den Mutex gesperrt hat, dann wartet dieser Befehl darauf, dass die Sperre aufgehoben wird und sperrt den Mutex dann seinerseits. (Sobald dieser Befehl zurückkehrt, ist garantiert, dass der Mutex erfolgreich durch diesen Thread gesperrt wurde).<BR>Dieser Sperr-Mechanismus wird normalerweise benutzt, um den Zugriff auf gemeinsame Datenstrukturen oder Resourcen zu koordinieren. <BR>Jeder Aufruf von Lock() muss mit einem nachfolgenden Aufruf von Unlock() aufgelöst werden.</P>
<H4 class="parameter">mutex</H4>
<P class="parametersummary">Die Identifikationsnummer des Mutex (wie von CreateMutex() zurückgeliefert)</P>
<H3 class="operation">Thread.Unlock (mutex)</H3>
<P class="operationsummary">Gibt einen Mutex wieder frei. Dieser Befehl darf nur nach einem vorangegangen Lock() benutzt werden.</P>
<H4 class="parameter">mutex</H4>
<P class="parametersummary">Die Identifikationsnummer des Mutex</P>
<H3 class="operation">Thread.Yield ()</H3>
<P class="operationsummary">Gibt die Kontrolle über die CPU explizit an dieser Stelle frei.<BR>Threads laufen oft nicht wirklich parallel, weil es nicht genug CPUs für alle Threads gibt. Statt dessen macht eine CPU ein wenig Arbeit für einen Thread und schaltet dann schnell zu einem anderen Thread weiter. Dadurch entsteht der Eindruck, dass alles parallel abläuft.<BR>Falls ein Thread gerade nichts zu tun hat, weil er gerade darauf wartet, dass irgendeine Bedingung eintritt, kann er die Kontrolle mit Yield() vorzeitig an andere Threads abgeben, die dann die Chance haben, ihre Arbeit durchzuführen.</P>
<H2 class="object">Vector</H2>
<P class="objectsummary">Dieses Objekt bietet verschiedene Operationen zur Manipulation größerer Zahlenmengen.<BR>Sie werden Vektoren genannt und werden in normalen Arrays mit fortlaufendem Index, beginnend bei 0, abgelegt.<BR>Wenn Operationen mit Arrays mit einer abweichenden Struktur aufgerufen werden, wird jedes fehlende Array-Element als 0 angenommen.</P>
<H3 class="operation">Vector.Add (size, A, B)</H3>
<P class="operationsummary">Addiert zwei Vektoren elementweise (C[0]=A[0]+B[0], C[1]=A[1]+B[2]...)</P>
<H4 class="parameter">size</H4>
<P class="parametersummary">Anzahl der Elemente von jedem Vektor für die Berechnung</P>
<H4 class="parameter">A</H4>
<P class="parametersummary">Erster Vektor</P>
<H4 class="parameter">B</H4>
<P class="parametersummary">Zweiter Vektor</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">A Vektor der angegebenen Größe, der alle Summen enhält.</P>
<H3 class="operation">Vector.Init (size, value)</H3>
<P class="operationsummary">Initialisiert einen Vektor mit angegebener Länge und Startwert für alle Elemente.</P>
<H4 class="parameter">size</H4>
<P class="parametersummary">Länge des Vektors</P>
<H4 class="parameter">value</H4>
<P class="parametersummary">Der Wert für alle Elemente</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Den neu erzeugten Vektor</P>
<H3 class="operation">Vector.Multiply (rows, columns, k, A, B)</H3>
<P class="operationsummary">Matrizenmultiplikation.<BR>Die Eingabevektoren werden jeweils als zweidimensioinale Matrix von gegebener Höhe und Breite interpretiert. Die einzelnen Zeilen der Matrix sind in den Vektor direkt nacheinander abgelegt.<BR>Mehr zur Definition von Matrizenmultiplikation gibt es auf: https://de.wikipedia.org/wiki/Matrizenmultiplikation .</P>
<H4 class="parameter">rows</H4>
<P class="parametersummary">Anzahl der Zeilen der Ergebnis-Matrix</P>
<H4 class="parameter">columns</H4>
<P class="parametersummary">Anzahl der Spalten der Ergebnis-Matrix</P>
<H4 class="parameter">k</H4>
<P class="parametersummary">Anzahl der Spalten in Matrix A und gleichzeitig der Zeilen in Matrix B</P>
<H4 class="parameter">A</H4>
<P class="parametersummary">Ein Matrix der Größe rows * k</P>
<H4 class="parameter">B</H4>
<P class="parametersummary">Eine Matrix der Größe k * columns</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Eine neue Matrix mit dem Multiplikationsergebnis</P>
<H3 class="operation">Vector.Sort (size, A)</H3>
<P class="operationsummary">Sortiert die Element eines Vektors in aufsteigender Reihenfolge.</P>
<H4 class="parameter">size</H4>
<P class="parametersummary">Anzahl der Elements</P>
<H4 class="parameter">A</H4>
<P class="parametersummary">Der zu sortierende Vektor</P>
<H4 class="returns">Rückgabewert</H4>
<P class="returnssummary">Ein neuer Vektor mit den sortierten Elementen</P>

<H1 class="chapter">Appendix - Sensors</H1>

<PRE>
Type  Mode  Name            get reading with   delivers 

1        0  NXT-TOUCH       ReadPercent        0=not pressed,  100=pressed  

4        0  NXT-COL-REF     ReadPercent        0=no reflective light, 100=maximum reflective light
4        1  NXT-COL-AMB     ReadPercent        0=no ambient light, 100=maximum ambient light
4        2  NXT-COL-COL     ReadRaw (1 value)  1=black, 2=blue, 3=green, 4=yellow, 5=red, 6=white

5        0  NXT-US-CM       ReadRaw (1 value)  distance in cm

16       0  TOUCH           ReadPercent        0=not pressed,  100=pressed  

29       0  COL-REFLECT     ReadPercent        0=no reflective light, 100=maximum reflective light
29       1  COL-AMBIENT     ReadPercent        0=no ambient light, 100=maximum ambient light
29       2  COL-COLOR       ReadRaw (1 value)  0=unknown, 1=black, 2=blue, 3=green, 4=yellow, 5=red, 6=white, 7=brown
29       4  RGB-RAW         ReadRaw (3 values) value1=red intensity, value2=green intensity, value3=blue intensity

33       0  IR-PROX         ReadPercent        distance in inch (not very accurate)
33       1  IR-SEEK         ReadRaw (2 values) direction and distance to IR beacon
33       2  IR-REMOTE       ReadRaw (4 values) value1=signal from channel 1 (*), value2=signal from channel 2...
                                    a remote control sender can be switched to use one of 4 channels 
                                    (slider on top position is channel 1) and the remote receiver can detect 
                                    all channel signals at the same time
                                               											       
(*) numbers for the remote control buttons (A=left top, B=left bottom, C=right top, D=right bottom, E=beacon activated):
	A = 1    A&B = 10   B&C = 7
	B = 2    A&C = 5    B&D = 8
	C = 3    A&D = 6    C&D = 11
	D = 4               E = 9
   other combinations give a reading of 0
</PRE>   

</BODY>
</HTML>
